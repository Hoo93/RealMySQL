# Chapter 4. 아키텍처

## 4.1 MySQL 엔진 아키텍처
### 4.1.1 MySQL 전체 구조
* MySQL(MySQL서버)은 MySQL 엔진과 스토리지 엔진으로 구성된다.
  1. MySQL 엔진
     - 커넥션 핸들러 : 클라이언트로부터의 쿼리 요청을 처리
     - 전처리기
     - SQL 파서
     - 옵티마이저
     - 쿼리 실행기
  2. 스토리지 엔진
      - 실제 데이터를 디스크에 저장하고 읽어오는 부분을 담당한다.
      - 플러그인으로 다양한 기능을 제공한다. -> 컴포넌트로 변경됨
      - InnoDB, MyISAM, Memory, CSV, Archive 등이 있다.

    
* ❗핸들러 API : MySQL 엔진과 스토리지 엔진 사이의 인터페이스
  - SHOW GLOBAL STATUS LIKE 'Handler%'; 명령어로 확인 가능

### 4.1.2 MySQL 스레딩 구조

* MySQL 서버는 프로세스 기반이 아닌 스레드 기반으로 동작한다.
  * [프로세스와 스레드란 ?](https://programmer-hoo.tistory.com/29)
    * 프로세스 : 운영체제로부터 자원을 할당받은 작업의 단위
    * 스레드 : 프로세스 내에서 실행되는 흐름의 단위
    * 프로세스:스레드 = 1:N
    * 프로세스는 독립된 메모리 영역을 가진다. 그러므로 컨텍스트 스위칭이 무겁고 자원의 공유가 어렵다.
    * 스레드는 프로세스 내의 메모리 영역을 공유한다. 그러므로 컨텍스트 스위칭이 가볍고 자원의 공유가 쉽다.

  * 스레드 기반의 RDBMS의 장점 (대표 : MySQL, Oracle, SQL Server)
    1. 스레드는 프로세스보다 가볍고 컨텍스트 스위칭이 빠르기 때문이다. 
    2. 스레드는 프로세스보다 자원을 적게 사용한다. 
    3. 스레드는 프로세스보다 자원을 공유하기 때문에 프로세스보다 효율적이다.

   * 프로세스 기반의 RDBMS의 장점 (대표 : PostgreSQL)
     1. 독립성 : 클라이언트연결마다 별개의 프로세스를 가진다.
     그렇기 때문에 하나의 프로세스에서 발생한 문제가 다른 연결에 영향을 주지 않는다.
     2. 보안: 프로세스 간 메모리가 분리되어 있어, 보안적인 측면에서 각 클라이언트의 데이터를 보호하는 데 유리합니다.
     3. 관리 용이성: 시스템 관리자가 각 프로세스를 개별적으로 모니터링하고 제어할 수 있어, 세밀한 리소스 관리가 가능합니다.

   * 프로세스 기반의 RDBMS의 단점
     1. 자원 사용량: 각 연결마다 별도의 프로세스가 메모리와 CPU 자원을 사용하기 때문에, 많은 수의 동시 연결이 발생할 경우 시스템의 자원을 많이 소모하게 됩니다.
     2. 오버헤드: 프로세스 간의 컨텍스트 스위칭이 빈번하게 발생할 수 있으며, 이는 성능 저하를 일으킬 수 있습니다.
     3. 통신 비용: 프로세스 간 통신(IPC)은 스레드 간 통신보다 복잡하고 느릴 수 있습니다.
    

* 스레드는 Foreground 스레드와 Background 스레드로 나뉜다.


* Foreground 스레드
  - 클라이언트가 요청하는 쿼리를 처리하는 스레드
  - 최소한 MySQL 서버에 접속한 클라이언트 수만큼 존재한다.
  - 작업을 종료하면 **스레드 캐시로** 이동한다.
  - 이 때 스레드 캐시의 최대 스레드 개수를 thread_cache_size로 설정할 수 있다.
  - Foreground 스레드는 데이터를 MySQL 데이터 버퍼나 캐시로부터 가져온다.
    - 데이터가 버퍼나 캐시에 없는 경우 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어온다.
    - 이 때 MyISAM은 Foreground 스레드가 직접 디스크에서 데이터를 읽어오지만,
    InnoDB는 데이터 버퍼, 캐시까지만 Foreground 스레드가 처리하고 버퍼로부터 디스크까지 기록하는 작업은 Background 스레드가 처리한다.

* Background 스레드
  * 크게 아래의 역할을 담당한다.
    1. 인서터 버퍼를 병합하는 스레드
    2. ❗️로그를 디스크로 기록하는 스레드 
    3. ❗️InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드 ( 위에서 설명 )
       * 그렇기 때문에 InnoDB는 지연된 쓰기가 가능하다 MyISAM은 불가능
    4. 데이터를 버퍼로 읽어 오는 스레드
    5. 잠금이나 데드락을 모니터링하는 스레드
  
### 4.1.3 메모리 할당 및 사용 구조

* MySQL의 메모리 공간은 크게 2가지 영역으로 나누어 사용한다.
  * 복잡한 내용이라 단순하게 MySQL 시스템 변수로 설정해 둔 만큼 운영체제로부터 할당 받는다고 생각하자
  1. Global Memory
  2. Session(Local) Memory
  

* 글로벌 메모리 영역
  * 클라이언트 스레드의 수와 무관하게 하나의 메모리 공간만 할당
  * 필요에 따라 2개 이상도 가능하지만 클라이언트 수와 무관
  * 대표적인 글로벌 메모리 영역
    1. 테이블 캐시
    2. InnoDB 버퍼 풀
    3. InnoDB 해시 인덱스
    4. InnoDB 리두 로그 버퍼


* 세션 메모리 영역
  * 클라이언트 스레드가 쿼리를 처리하기 위해 사용하는 메모리 영역
  * 클라이언트가 사용해서 클라이언트 메모리 영역이라고도 함
  * 클라이언트와 MySQL 서버와의 커넥션을 **세션**이라고 하기 때문에
  세션 메모리 영역이라고도 함
  * 스레드별로 독립적으로 할당되기 떄문에 절대 공유되지 않는다.
    * 부적절하게 설정하면 메모리 부족으로 멈출 수 있다. ( 희박함 )
  * 필요할 때만 할당되고 할당조차 하지 않을 수도 있다. (소트버퍼, 조인버퍼)
  * 커넥션 상태에 따라 두 가지 종류로 나뉜다.
    * 커넥션이 열려 있는 동안 계속 열려있는 메모리 영역
    * 쿼리를 실행하는 순간에만 할당했다가 해제하는 메모리 영역 (소트버퍼, 조인버퍼)
  * 대표적인 세션 메모리 영역
    1. 정렬 버퍼
    2. 조인 버퍼
    3. 바이너리 로그 캐시
    4. 네트워크 버퍼


### 4.1.4 플러그인 스토리지 엔진 모델

* MySQL은 독특하게 플러그인을 지원한다.
* MySQL엔진이 아닌 스토리지 엔진을 플러그인으로 추가할 수 있다.
* MySQL 8.0부터는 컴포넌트로 변경되었다.


### 4.1.6 쿼리 실행 구조

쿼리 실행 순서는 아래와 같다.

1. 클라이언트의 SQL 요청
2. [MySQL 엔진] 커넥션 핸들러
3. [MySQL 엔진] 쿼리 파서
4. [MySQL 엔진] 전처리기
5. [MySQL 엔진] 옵티마이저
6. [MySQL 엔진] 쿼리 실행기
7. [스토리지 엔진] 데이터 읽기/쓰기
8. [MySQL 엔진] 결과 반환


* 쿼리 파서
  * 쿼리 파서는 사용자가 요청한 쿼리 문장을 토큰으로 분리해 트리 형태의 구조로 만드는 작업
    * 토큰 : MySQL이 인식할 수 있는 최소 단위의 어휘나 기호
  * 기본 문법 오류는 이 과정에서 발견된다.
* 전처리기
  * 쿼리 파서에 의해 만들어진 트리 기반의 쿼리 문장에서 구조적인 문제점이 있는지 확인한다.
  * 테이블 명, 칼럼 명, 내장 함수와 같은 객체를 매핑해 실제 객체가 존재하는지 확인한다.
  * 접근 권한을 확인한다.
  * 실제 존재하지 않는 객체이거나 권한이 없는 객체에 접근하려고 하면 에러를 발생시킨다.
* ❗️옵티마이저
  * DBMS의 두뇌
  * 쿼리 문장을 저렴한 비용으로 가장 빠르게 실행할 수 있는 실행 계획을 수립한다.
  * RDBMS의 성능을 결정짓는 중요한 요소
  * RDMBS를 잘 다룬 다는 것은 옵티마이저가 더 나은 선택을 할 수 있도록 유도하는 것
* 실행 엔진
  * 옵티마이저가 수립한 실행 계획을 실제로 실행하는 역할
  * 만들어진 계획대로 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할
* 핸들러 (스토리지 엔진)
  * 데이터를 디스크로 저장하고 읽어 오는 역할
  * 결국 스토리지 엔진을 의미


### 4.1.8 쿼리 캐시

* 쿼리 캐시는 SQL의 실행 결과를 메모리에 캐시하고 있다가 동일한 SQL이 요청되면 캐시된 결과를 반환하는 기능
* 성능을 향상시키지만 테이블 데이터에 변경이 있는 경우 캐시를 삭제해야 하므로 심각한 성능 저하를 유발했음
* MySQL 8.0 부터는 쿼리 캐시 기능을 완전히 제거함

### 4.1.9 스레드 풀

* MySQL 엔터프라이즈 기능이지만 
커뮤니티 에디션에서는 Percona Server에서 제공하는 스레드 풀 기능이 있다.
* Percona Server는 플러그인 형태로 작동한다.

* 스레드 풀 : 사용자의 요청을 처리하는 스레드 개수를 줄여
MySQL 서버의 CPU가 제한된 개수의 스레드 처리에만 집중할 수 있도록 해
자원의 소모를 줄이는 것이 목적
* 스레드들을 CPU가 최대한 잘 처리해낼 수 있는 수준으로 줄여서 빨리 처리하게 해야함
* 적절하게 설정하면 CPU의 프로세서 친화도가 높이고 컨텍스트 스위치 비용을 줄일 수 있음
* Percona Server의 스레드 풀은 기본적으로 CPU 코어 개수만큼 스레드 그룹을 생성함
  * thread_pool_size 옵션을 통해 조정 가능
  * 일반적으로 CPU 개수만큼 사용하는 것이 CPU 프로세서 친화도를 높이는 데 좋음
  * 모든 스레드가 사용 중인 경우 thread_pool_stall_limit 만큼 기다려도 처리 중인 작업이 끝나지 않은 경우
  새로운 스레드를 생성해 스레드 그룹에 추가한다.
  * 그러므로 thread_pool_stall_limit 이 0에 가까운 것은 의미가 없음
  * Percona Server는 선순위 큐, 후순위 큐를 이용해 특정 쿼리를 우선처리할 수 있는 기능도 제공
  * 



